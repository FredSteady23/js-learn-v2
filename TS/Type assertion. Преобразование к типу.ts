// Type assertion представляет модель преобразования значения переменной к определенному типу. Обычно в некоторых ситуациях одна переменная может представлять какой-то широкий тип, например, any или union, которые по факту допускают значения различных типов. Однако при этом нам надо использовать переменную как значение строго определенного типа. И в этом случае мы можем привести к этому типу.

// В качестве примера возьмем простейшую задачу - на веб-странице есть html-элемент с id = header, и мы хотим получить этот элемент, например, чтобы изменить его текст. Для получения элемента по id мы могли бы использовать встроенную js-функцию document.getElementById():
// 1
// 2
	
// const header = document.getElementById("header");
// header.innerText = "Hello Typescript!";

// Но в TypeScript эта функция возвращает объединение HTMLElement|null. То есть возвращаемое значение может представлять null, если соответствующий html-элемент отсутствует на веб-странице. Вследствие этого обращение к свойству header.innerText - к свойству объекта, который может быть null, содержит потенциальную ошибку. Поэтому компилятор при компиляции сгенерирует ошибку.

// Однако ситуация может быть такова, что мы точно знаем, что у нас на странице есть такой элемент. Есть разные способы для решения этой проблемы, чтобы указать компилятору, что все нормально. И одним из ним является приведение типов с помощью type assertion.

// Есть две формы приведения. Первая форма заключается в использовании угловых скобок:
// 1
// 2
	
// const header = <HTMLElement>document.getElementById("header");
// header.innerText = "Hello Typescript!";

// Перед значением в угловых скобках указывается тип, к которому надо выполнить приведение. Так, в данном случае мы получаем объект типа HTMLElement

// Вторая форма заключается в применении оператора as, после которого указывается тип, к которому надо выполнить преобразование:
// 1
// 2
	
// const header = document.getElementById("header") as HTMLElement;
// header.innerText = "Hello Typescript!";

// Однако такие преобразования будут иметь силу, если мы точно знаем, что значение может быть преобразовано к целевому типу. Например, на странице есть элемент с id=header, поэтому мы можем преобразовать значение к типу HTMLElement. Однако если такого элемента нет, то во время выполнения мы опять же получим ошибку.